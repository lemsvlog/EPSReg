<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Passport/ID Photo Resizer (Offline)</title>
  <style>
    :root{
  --bg-1:#03121f;          /* deep arctic night */
  --bg-2:#0a1e2e;          /* card/modal base */
  --text:#eef6ff;          /* main text */
  --muted:#a9c3d9;         /* muted text */
  --accent:#38bdf8;        /* sky blue */
  --accent-2:#0ea5e9;      /* deeper sky */
  --cyan:#67e8f9;          /* icier cyan */
  --cyan-2:#22d3ee;
  --danger:#ef4444;

  --border:1px solid rgba(103,232,249,.25);
  --shadow:0 12px 28px rgba(0,0,0,.45);
  --ring:0 0 18px rgba(56,189,248,.55), 0 0 32px rgba(103,232,249,.35);
  --radius:14px;
  --radius-lg:18px;
}

body{
  margin:0;
  background:
    radial-gradient(1200px 800px at 5% -10%, rgba(56,189,248,.18), transparent 60%),
    radial-gradient(1200px 800px at 120% 110%, rgba(103,232,249,.16), transparent 60%),
    linear-gradient(180deg, var(--bg-1), #061a2b 65%, #04121e);
  color:var(--text);
  font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
}

/* topbar, card, btn, uploader, etc. */
.topbar{
  position:sticky;top:0;z-index:5;
  background:rgba(10,30,46,.8);
  color:#fff;
  padding:12px 16px;
  box-shadow:0 2px 10px rgba(0,0,0,.5);
  display:flex;gap:12px;align-items:center;justify-content:center;
  border-bottom:1px solid rgba(103,232,249,.35);
  backdrop-filter:blur(8px) saturate(130%);
}

.card{
  background:linear-gradient(180deg, #0e1a2b, #0a1422);
  border:var(--border);
  border-radius:var(--radius);
  box-shadow:var(--shadow);
  backdrop-filter:blur(6px);
  color:var(--text);
}
.card h2{margin:0;padding:16px;border-bottom:var(--border);font-size:18px;color:var(--cyan);}
.card .body{padding:16px}

.btn{
  appearance:none;border:0;
  border-radius:12px;padding:10px 14px;
  font-weight:600;cursor:pointer;
  background:linear-gradient(90deg,var(--cyan),var(--accent));
  color:#04101e;
  box-shadow:var(--shadow);
  transition:all .2s ease;
}
.btn:hover{filter:brightness(1.1);box-shadow:var(--ring)}
.btn.ghost{background:rgba(255,255,255,.08);color:var(--text);border:var(--border);box-shadow:none}
.btn.secondary{background:linear-gradient(90deg,#06b6d4,#0ea5e9);color:#04101e}
.btn.danger{background:#ef4444;color:#fff}
</style>

  <div class="topbar"><strong>Photo Resizer</strong>&nbsp;—&nbsp;Templates: <strong>3.5×4.5 cm</strong> or <strong>800×600 px</strong>. Fully offline.</div>

  <div class="wrap grid">
    <!-- Left: Workspace -->
    <section class="card">
      <h2>Workspace</h2>
      <div class="body">
        <div class="row" style="justify-content:space-between;flex-wrap:wrap">
          <div class="field" style="min-width:260px;max-width:380px;flex:1">
            <label>Template</label>
            <div class="seg" role="tablist" aria-label="Template selector">
              <button id="tmplID" class="pill active" data-tmpl="id">ID – 3.5×4.5 cm (413×531)</button>
              <button id="tmplPP" class="pill" data-tmpl="passport">Passport – 800×600 px</button>
            </div>
          </div>
          <div class="field" style="width:180px">
            <label>Preview width (screen)</label>
            <input type="number" min="180" max="420" step="10" id="previewWidth" value="400">
          </div>
          <div class="field" style="width:140px">
            <label>DPI (info)</label>
            <input type="number" id="dpi" value="300" step="1">
          </div>
        </div>

        <label class="uploader" for="fileInput" id="dropArea" style="margin-top:10px">
          <div>
            <div style="font-weight:700;font-size:16px">Upload or Drop a Photo</div>
            <div class="small">JPG Only • Large photos are ok</div>
          </div>
          <input id="fileInput" type="file" accept="image/*" hidden>
        </label>

        <div class="preview-wrap" id="workspace" style="display:none">
          <div class="helper">Drag to move • Zoom • Fit • Rotate • Template keeps fixed aspect</div>
          <div class="stage">
            <div class="frame" id="frame" style="width: 290px; height: 374px;">
              <canvas id="screenCanvas" width="290" height="374" style="display:block; width:100%; height:100%"></canvas>
            </div>
          </div>

          <div class="controls mt12">
            <button class="btn" id="zoomIn">＋ Zoom In</button>
            <button class="btn" id="zoomOut">－ Zoom Out</button>
            <button class="btn ghost" id="fit">Fit to Frame</button>
            <button class="btn ghost" id="center">Center</button>
            <button class="btn ghost" id="reset">Reset</button>
            <button class="btn secondary" id="rotate">Rotate 90°</button>
          </div>

          <div class="note mt12" id="noteText">Output: <strong>413 × 531 px</strong> (≈3.5×4.5 cm @300 DPI)</div>
        </div>
      </div>
    </section>

    <!-- Right: Download options -->
    <aside class="right">
      <section class="card">
        <h2>Download (Target File Size)</h2>
        <div class="body">
          <div class="field"><label>File type</label>
           <div class="btn-row">
  <button class="btn ghost active" data-type="image/jpeg" id="typeJpg" aria-pressed="true">JPG</button>
</div>
<div class="small">JPG format only</div>
            <div class="small">JPG recommended for IDs.</div>
          </div>

          <hr class="mt12"/>

          <div id="dlBlock">
            <!-- This block's labels/defaults change with template -->
            <div class="cols-2">
              <div class="field"><label id="optLabel1">Option A</label><input id="opt1" type="number" step="0.1" value="13"> <div class="small">KB</div></div>
              <button class="btn" id="dl1">Download A</button>
            </div>
            <div class="cols-2 mt8">
              <div class="field"><label id="optLabel2">Option B</label><input id="opt2" type="number" step="0.1" value="12"> <div class="small">KB</div></div>
              <button class="btn" id="dl2">Download B</button>
            </div>
            <div class="cols-2 mt8">
              <div class="field"><label id="optLabel3">Option C</label><input id="opt3" type="number" step="0.1" value="11"> <div class="small">KB</div></div>
              <button class="btn" id="dl3">Download C</button>
            </div>
          </div>

          <hr class="mt12"/>
          <div class="field">
            <label>Advanced (optional)</label>
            <div class="cols">
              <div class="field"><label>Min quality</label><input id="minQ" type="number" step="0.01" min="0.1" max="0.95" value="0.25"></div>
              <div class="field"><label>Max quality</label><input id="maxQ" type="number" step="0.01" min="0.3" max="1" value="0.95"></div>
              <div class="field"><label>Tolerance</label><input id="tol" type="number" step="0.1" min="0.5" value="0.8"><div class="small">KB ±</div></div>
            </div>
          </div>
        </div>
      </section>
    </aside>
  </div>

  <div class="footer">Made for quick passport/ID crops. Works fully offline. No external libraries.</div>

  <script>
  // ===== Templates =====
  const TEMPLATES = {
    id: { name:'ID_3.5x4.5cm', outW:413, outH:531, dpi:300, note:'Output: 413 × 531 px (≈3.5×4.5 cm @300 DPI)', presets:[13,12,11] },
    passport: { name:'Passport_800x600', outW:800, outH:600, dpi:300, note:'Output: 800 × 600 px (passport)', presets:[90,85,75] }
  };

  // State (mutable)
  let current = { key:'id', ...TEMPLATES.id };

  // ===== DOM Refs =====
  const TARGET_DPI_INPUT = document.getElementById('dpi');
  const screenCanvas = document.getElementById('screenCanvas');
  const sctx = screenCanvas.getContext('2d');
  const frameEl = document.getElementById('frame');
  const previewWidthInput = document.getElementById('previewWidth');
  const noteText = document.getElementById('noteText');

  const tmplID = document.getElementById('tmplID');
  const tmplPP = document.getElementById('tmplPP');

  const fileInput = document.getElementById('fileInput');
  const dropArea = document.getElementById('dropArea');
  const workspace = document.getElementById('workspace');

  const btnZoomIn = document.getElementById('zoomIn');
  const btnZoomOut = document.getElementById('zoomOut');
  const btnFit = document.getElementById('fit');
  const btnCenter = document.getElementById('center');
  const btnReset = document.getElementById('reset');
  const btnRotate = document.getElementById('rotate');

const typeJpg = document.getElementById('typeJpg');
let mimeType = 'image/jpeg';

  const opt1 = document.getElementById('opt1');
  const opt2 = document.getElementById('opt2');
  const opt3 = document.getElementById('opt3');
  const dl1 = document.getElementById('dl1');
  const dl2 = document.getElementById('dl2');
  const dl3 = document.getElementById('dl3');

  const minQ = document.getElementById('minQ');
  const maxQ = document.getElementById('maxQ');
  const tolKB = document.getElementById('tol');

  // Image & view state
  let img = new Image();
  let loaded = false;
  let scale = 1;        // zoom factor
  let pos = {x: 0, y: 0}; // pan offset (px in output space reference)
  let angle = 0;        // rotation 0, 90, 180, 270

  // ===== Template handling =====
  function applyTemplate(tkey){
    current = { key:tkey, ...TEMPLATES[tkey] };
    TARGET_DPI_INPUT.value = String(current.dpi);
    // Update preview frame size according to aspect
    setPreviewWidth(previewWidthInput.value);
    noteText.textContent = current.note;
    // Update default size presets
    [opt1.value,opt2.value,opt3.value] = current.presets.map(v=>String(v));
    // Visual active state
    [tmplID, tmplPP].forEach(b=>b.classList.remove('active'));
    (tkey==='id'?tmplID:tmplPP).classList.add('active');
    // Keep composition but refit to new aspect if image is loaded
    if(loaded){ fitToCover(); draw(); }
  }

  tmplID.onclick = ()=>applyTemplate('id');
  tmplPP.onclick = ()=>applyTemplate('passport');

  // ===== Preview frame sizing =====
  function setPreviewWidth(w){
    w = Math.max(180, Math.min(420, Number(w)||320));
    const ratio = current.outH / current.outW;
    const h = Math.round(w * ratio);
    frameEl.style.width = w + 'px';
    frameEl.style.height = h + 'px';
    screenCanvas.width = w;
    screenCanvas.height = h;
    draw();
  }
  previewWidthInput.addEventListener('change', e=> setPreviewWidth(e.target.value));

  // Init default template and frame
  applyTemplate('id');

  // ===== Interactions =====
  let isDragging = false, last = {x:0,y:0};
  screenCanvas.addEventListener('pointerdown', e=>{
    isDragging = true; last = {x:e.clientX, y:e.clientY}; screenCanvas.setPointerCapture(e.pointerId);
  });
  screenCanvas.addEventListener('pointermove', e=>{
    if(!isDragging) return;
    const dx = e.clientX - last.x; const dy = e.clientY - last.y; last = {x:e.clientX,y:e.clientY};
    const scaleScreenToOut = current.outW / screenCanvas.width; // proportional for both axes
    pos.x += dx * scaleScreenToOut;
    pos.y += dy * scaleScreenToOut;
    draw();
  });
  screenCanvas.addEventListener('pointerup', ()=>{isDragging=false});
  screenCanvas.addEventListener('pointercancel', ()=>{isDragging=false});

  btnZoomIn.onclick = ()=>{ scale *= 1.05; draw(); };
  btnZoomOut.onclick = ()=>{ scale /= 1.05; draw(); };
  btnCenter.onclick = ()=>{ pos = {x:0,y:0}; draw(); };
  btnReset.onclick = ()=>{ resetView(); };
  btnRotate.onclick = ()=>{ angle = (angle + 90) % 360; fitToCover(); draw(); };
  btnFit.onclick = ()=>{ fitToCover(); draw(); };

  function resetView(){ scale = 1; pos = {x:0,y:0}; angle = 0; fitToCover(); draw(); }

  function fitToCover(){
    if(!img.naturalWidth) return;
    const iw = (angle % 180 === 0) ? img.naturalWidth : img.naturalHeight;
    const ih = (angle % 180 === 0) ? img.naturalHeight : img.naturalWidth;
    const s = Math.max(current.outW/iw, current.outH/ih); // cover
    scale = s; pos = {x:0,y:0};
  }

  function draw(){
    sctx.clearRect(0,0,screenCanvas.width,screenCanvas.height);
    if(!loaded) return;
    const out = renderToOutputCanvas();
    sctx.imageSmoothingEnabled = true; sctx.imageSmoothingQuality = 'high';
    sctx.drawImage(out, 0, 0, screenCanvas.width, screenCanvas.height);
  }

  function renderToOutputCanvas(){
    const oc = document.createElement('canvas'); oc.width = current.outW; oc.height = current.outH; const octx = oc.getContext('2d');
    octx.fillStyle = '#ffffff'; octx.fillRect(0,0,oc.width,oc.height);
    octx.save();
    octx.translate(current.outW/2 + pos.x, current.outH/2 + pos.y);
    octx.rotate(angle * Math.PI/180);
    const iw = img.naturalWidth; const ih = img.naturalHeight;
    const drawW = iw * scale; const drawH = ih * scale;
    octx.imageSmoothingEnabled = true; octx.imageSmoothingQuality = 'high';
    octx.drawImage(img, -drawW/2, -drawH/2, drawW, drawH);
    octx.restore();
    return oc;
  }

  function bytesToKB(bytes){ return bytes/1024; }
  function fileNameFor(kb){ return `${current.name}_${Math.round(kb*10)/10}KB.jpg`; }

  async function canvasToBlobWithQuality(canvas, type, quality){
    return new Promise(resolve=> canvas.toBlob(b=>resolve(b), type, quality));
  }

// ===== NEW: Auto-tuned JPEG export =====
async function exportAtTargetKB(targetKB){
  const type = mimeType;
  const outCanvas = renderToOutputCanvas();



  const {
    blob, actualKB, usedQ, usedTolKB, usedMinQ, usedMaxQ
  } = await tuneJpegQuality(outCanvas, targetKB);

  try{
    minQ.value = usedMinQ.toFixed(2);
    maxQ.value = usedMaxQ.toFixed(2);
    tolKB.value = usedTolKB.toFixed(1);
  }catch(_){ }

  return { blob, actualKB, used:{ q:usedQ, tolKB:usedTolKB, minQ:usedMinQ, maxQ:usedMaxQ } };
}

// Helper
async function tuneJpegQuality(canvas, targetKB){
  const GLOBAL_MIN_Q = 0.05;
  const GLOBAL_MAX_Q = 0.99;
  const autoTolKB = Math.max(0.6, targetKB * 0.012);

  async function probe(q){
    const b = await canvasToBlobWithQuality(canvas, 'image/jpeg', q);
    return { q, kb: bytesToKB(b.size), blob: b };
  }

  let lo = await probe(GLOBAL_MIN_Q);
  let hi = await probe(GLOBAL_MAX_Q);

  if (targetKB <= lo.kb + autoTolKB) {
    return { blob: lo.blob, actualKB: lo.kb, usedQ: lo.q, usedTolKB: autoTolKB, usedMinQ: GLOBAL_MIN_Q, usedMaxQ: GLOBAL_MAX_Q };
  }
  if (targetKB >= hi.kb - autoTolKB) {
    return { blob: hi.blob, actualKB: hi.kb, usedQ: hi.q, usedTolKB: autoTolKB, usedMinQ: GLOBAL_MIN_Q, usedMaxQ: GLOBAL_MAX_Q };
  }

  let loQ = GLOBAL_MIN_Q, hiQ = GLOBAL_MAX_Q;
  let best = { blob: hi.blob, actualKB: hi.kb, q: hiQ };

  for(let i=0; i<26; i++){
    const midQ = (loQ + hiQ) / 2;
    const mid = await probe(midQ);
    if (Math.abs(mid.kb - targetKB) < Math.abs(best.actualKB - targetKB)) {
      best = { blob: mid.blob, actualKB: mid.kb, q: midQ };
    }
    if (Math.abs(mid.kb - targetKB) <= autoTolKB) {
      return { blob: mid.blob, actualKB: mid.kb, usedQ: midQ, usedTolKB: autoTolKB, usedMinQ: loQ, usedMaxQ: hiQ };
    }
    if (mid.kb > targetKB) {
      hiQ = midQ;
    } else {
      loQ = midQ;
    }
  }
  return { blob: best.blob, actualKB: best.actualKB, usedQ: best.q, usedTolKB: autoTolKB, usedMinQ: loQ, usedMaxQ: hiQ };
}

  function triggerDownload(blob, suggestedKB){
    const a = document.createElement('a');
    const url = URL.createObjectURL(blob);
    a.href = url;
    a.download = fileNameFor(suggestedKB);
    document.body.appendChild(a);
    a.click();
    setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 0);
  }

  async function handleDownload(targetInput){
    if(!loaded){ alert('Please upload a photo first.'); return; }
    const target = Number(targetInput.value);
    if(!target || target <= 0){ alert('Enter a valid KB size.'); return; }
    const {blob, actualKB} = await exportAtTargetKB(target);
    triggerDownload(blob, target);
    const tol = Math.max(0.1, Number(tolKB.value)||0.8);
    if(Math.abs(actualKB - target) > tol){
      setTimeout(()=>{ alert(`Note: Could not reach exactly ${target}KB. Actual ≈ ${actualKB.toFixed(2)}KB. Adjust options if needed.`); }, 10);
    }
  }

  dl1.onclick = ()=>handleDownload(opt1);
  dl2.onclick = ()=>handleDownload(opt2);
  dl3.onclick = ()=>handleDownload(opt3);

  function setType(btn){
    [typeJpg,typePng].forEach(b=>b.classList.remove('active'));
    btn.classList.add('active');
    mimeType = btn.dataset.type;
  }
 typeJpg.onclick = ()=>setType(typeJpg);
setType(typeJpg);

  fileInput.addEventListener('change', (e)=>{
    const f = e.target.files && e.target.files[0]; if(!f) return; loadImageFile(f);
  });

  ['dragenter','dragover','dragleave','drop'].forEach(evt=>{
    dropArea.addEventListener(evt, e=>{e.preventDefault();e.stopPropagation();}, false);
  });
  dropArea.addEventListener('drop', e=>{
    const dt = e.dataTransfer; const f = dt.files && dt.files[0]; if(f) loadImageFile(f);
  });

  function loadImageFile(file){
    const url = URL.createObjectURL(file);
    img = new Image();
    img.onload = ()=>{ URL.revokeObjectURL(url); loaded = true; workspace.style.display = 'flex'; resetView(); draw(); };
    img.onerror = ()=>{ alert('Could not load image.'); };
    img.src = url;
  }

  TARGET_DPI_INPUT.addEventListener('change', ()=>{/* info only */});
  </script>
</body>
</html>


